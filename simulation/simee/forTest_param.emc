// Параметры реконструкции в электромагнитном калориметре.
// Обозначения: 
// lkr - башни в криптоне, str - полоски, csi - кристаллы, emc - lkr+csi
// See different tips at the end of this file


///////////////////////////////////////////////////////////////////////////////
// ОСНОВНОЕ УПРАВЛЕНИЕ РЕКОНСТРУКЦИЕЙ                                        //
///////////////////////////////////////////////////////////////////////////////

emc_verbose=1;                 ///< печать на экран (см. описание ниже)

//! источник номера захода для загрузки статусов каналов, при обработке моделирования

//!  Воспринимаются следующие значения:
//!  
//!  \li 0 - номер захода берётся из kglobalparam_.NSimRun \n
//!      Используется для загрузки статусов только если sim4exp_bad не равен 0.
//!  \see VDDCRec/kglobparam.h
//!  \li 1 - номер захода берётся из параметра sim4exp_bad
//!
//! Используеся в emc_run()
//! \see sim4exp_bad
emc_master=0;

read_lkr=1;                    ///< читать LKr запись, заполнять массив [9600] с амплитудами
read_csi=1;                    ///< читать CsI запись, заполнять массив [1536] с амплитудами

rec_lkr=1;                     ///< искать кластеры в LKr(башни)
rec_csi=1;                     ///< искать кластеры в CsI
rec_str=1;                     ///< искать кластеры в LKr(полоски)
rec_str_tracks=1;              ///< строить треки по LKr(полоски)

attach_lkr2str=1;              ///< приписывать башенным кластерам полосочные (только криптон)
attach_lkr2csi=1;              ///< приписывать кластеры LKr(башни) кластерам CsI. И наоборот.
attach_lkr2dc=0;               ///< приписывать кластеры LKr(башни) трекам ДК 
attach_csi2dc=0;               ///< приписывать кластеры CsI трекам ДК
dctrack_mode=2;                ///< способ продолжения треков ДК в калориметры (см. ниже)

fill_structure=1;              ///< заполнять C-структуру из emc_system.h с данными реконструкции (для пользователей фортрана)


///////////////////////////////////////////////////////////////////////////////
// ЭНЕРГИЯ                                                                   //
///////////////////////////////////////////////////////////////////////////////

//! множитель энергии в LKr (exp,sim)
//lkr_scale=1.061,   1.088;	
//lkr_scale=1.061,   1.097;	// v43
lkr_scale=1.061,   1.091;	// v54
//lkr_scale=1.059,   1.087;	// v52
//! множитель энергии в CsI (exp,sim)
//csi_scale=1.09, 1.17;
//csi_scale=1.09, 1.24;
//csi_scale=1.09, 1.18;
//csi_scale=1.07, 1.19;
//csi_scale=1.05, 1.16;	// v52
//csi_scale=1.02, 1.15;	// v53
csi_scale=1.05, 1.15;	// v53
//csi_scale=1.11, 1.23;
//csi_scale=1.11, 1.13;
lkr_scale_cosm = 1;            ///< экспериментальный scale поправляется на космический коэффициент  из БД

//lkr_simnoise=0;                ///< мешать шумы в моделирование (соответственно намоделировано должно быть без шумов)
lkr_simnoise=1;                ///< мешать шумы в моделирование (соответственно намоделировано должно быть без шумов)
lkr_noisepars=0.8,2.5;		// default


csi_simnoise=1;                ///< мешать шумы в моделирование (соответственно намоделировано должно быть без шумов)
//! шум в канале (МэВ), величина порога (в сигмах шума) для имитирования чтения с превышением
csi_noisepars=0.2,15.0;	// default


lkr_sim_spreads=0.,6.,0.,1.0,0.,1.2;	// lkr_sim_spreads[1] - m2c_spread(%) lkr_sim_spreads[3] - factor for thresholds, lkr_sim_spreads[5] - factor for noise
//csi_sim_spreads=0.,11.,0.,1.0,0.;	// csi_sim_spreads[1] - m2c_spread(%) csi_sim_spreads[3] - factor for thresholds
csi_sim_spreads=0.,20.,0.,1.0,0.;	// csi_sim_spreads[1] - m2c_spread(%) csi_sim_spreads[3] - factor for thresholds

sim4exp_lkr_noise=1; 	       ///<  Загрузить реальные шумы. Активно только при sim4exp_bad != 0

//! режим использользования экспериментальных статусов каналов при обработке моделирования

//! \li если значение равно 0, то моделирование обрабатывается с идеальным состоянием калориметра,
//! \li если отлично от нуля, то число используется как номер захода, для которого брать статус каналов.
//!     при #emc_master=0, ненулевое значение sim4exp_bad позволяет использовать номер захода,
//!     полученный из вне, для загрузки статусов.
//! 
//! Используеся в emc_run()
//! \see emc_master
sim4exp_bad=1;                 

csi_bad_channels = 2;          ///< учет плохих каналов 0/1/2 - не учитывать, основываться на mev2ch, читать из БД
//csi_bad_channels = 0;          ///< учет плохих каналов 0/1/2 - не учитывать, основываться на mev2ch, читать из БД

lkr_bad_mode = 1;              ///< 1 - учитывать звенящие ( kRING ) как поломанные( kBROKEN )
csi_bad_mode = 3;              ///< 1 - учитывать звенящие ( kRING ) как поломанные( kBROKEN )
                               ///< 2 - учитывать звенящие^2 ( kRING2 ) как kBROKEN, 3=1+2.

csi_mev2ch_tid = 1520;         ///< номер таблицы для коэффициента мэв/канал, если 0, то брать из файла
csi_mev2ch_fname =/space/users/pospelov/csicalib2/5477-5579_1/csimev2ch.txt; ///< имя файла

//! номер таблицы для mev2ch и ее версия
lkr_mev2ch_tid = 1657,2;

///////////////////////////////////////////////////////////////////////////////
// Состояние каналов                                                         //
///////////////////////////////////////////////////////////////////////////////
lkr_qlty_method = 2;        ///< способ получения статусов: 1-стандартный, 2-новый

lkr_calibsts_ver = 101;    ///< Версия таблицы статусов каналов по калибровкам
lkr_monitorsts_ver = 101;  ///< Версия таблицы статусов каналов по монитору заходов

lkr_qlty_tid = 1601;        ///< номер таблицы lkrqlty
//! массив версий таблицы lkrqlty
lkr_qlty_ver = 102, 100, 2, 0, -1, -1, -1, -1;

//! Максимальный возраст калибровочной записи о качестве канала
lkr_qlty_maxage = 10 days;    
   
csi_qlty_tid = 1523;           ///< 1523 - номер таблицы csieqlty
//! массив версий таблицы csieqlty
csi_qlty_ver = 101, -1, -1, -1, -1, -1, -1, -1;
//csi_qlty_ver = 102, 100, 2, 0, -1, -1, -1, -1;
//! Максимальный возраст калибровочной записи о качестве канала
csi_qlty_maxage = 10 days;   


///////////////////////////////////////////////////////////////////////////////
// СТРОИТЕЛЬСТВО                                                             //
///////////////////////////////////////////////////////////////////////////////

// параметры для поиска кластеров в LKr башнях 
//! пороги (МэВ) на энергию для включения ячеек в кластер (cell, near, seed)
//lkr_cell_ecut=1.5, 1.5,10.0;
lkr_cell_ecut=1.5, 1.5,8.0;
//lkr_cell_ecut=1.5, 1.5, 20.0;

//! пороги на сигнал/шум для включения ячеек в кластер (cell, near, seed)
//lkr_cell_rcut=2.5, 3.0, 5.0;   
lkr_cell_rcut=2.5, 3.0, 4.0;   
//lkr_cell_rcut=2.5, 3.0, 15.0;   

//! порог (МэВ) на энергию кластера
//lkr_cluster_ecut=10.;
lkr_cluster_ecut=20.;

//! порог снизу на число ячеек в кластере (оно должно быть не меньше указанного)
//lkr_cluster_ncells=2;
lkr_cluster_ncells=1;
//! 1 - сливать граничные, 2 - сливать через плохую ячейку, 3 - 1+2
lkr_merge=0;
//! размер окна, ограничивающего распространение кластера, 0 - ограничение выключено
lkr_wincut=0;

// параметры для поиска кластеров в CsI
//! пороги (МэВ) на энергию для включения ячеек в кластер (cell, near, seed)
//csi_cell_ecut=1.0, 1.5,10.0;

//csi_cell_ecut=1.0, 1.5,8.0;
csi_cell_ecut=1.5, 1.5,8.0;

//! порог (МэВ) на энергию кластера
//csi_cluster_ecut=10.;
csi_cluster_ecut=20.;
//! порог снизу на число ячеек в кластере (оно должно быть не меньше указанного)
csi_cluster_ncells=1;
//! 1 - сливать граничные, 2 - сливать через плохую ячейку, 3 - 1+2
csi_merge=0;
//! размер окна, ограничивающего распространение кластера, 0 - ограничение выключено
csi_wincut=0;
// Партнёры
//! 1 - сливать партнёров (близкие кластеры) в LKr и CsI, 0 - нет (по умолчанию)
emc_merge_partners=0;


// параметры для поиска кластеров в LKr полосках
//! пороги (МэВ) на энергию для включения ячеек в кластер (cell, near, seed)
//str_cell_ecut=0.0, 0.5, 4.0;
str_cell_ecut=0.5, 0.5, 3.0;
//! пороги на сигнал/шум для включения ячеек в кластер (cell, near, seed)
//str_cell_rcut=1.0, 2.0, 3.0;
str_cell_rcut=2.0, 2.0, 4.0;
//! порог (МэВ) на энергию кластера
str_cluster_ecut=3.0;
str_cluster_ncells=2;          ///< порог снизу на число ячеек в кластере (оно должно быть не меньше указанного)
str_merge=0;                   ///< 1 - сливать граничные, 2 - сливать через плохую ячейку, 3 - 1+2
str_wincut=0;                  ///< размер окна, ограничивающего распространение кластера
str_distmaxcells=5;            ///< порог расстояние между максимальными ячейками соприк. кластеров, иначе сливаться

// параметры для построения треков по полоскам
str_tracks_merge=0;            ///< сливать короткие треки в длинные (космика)
str_tracks_angle=20.;          ///< порог на угол между треками на слияние
str_tracks_distance=20.;       ///< порог на расстояние между x0,y0,z0 двух треков


///////////////////////////////////////////////////////////////////////////////
// ПРИСОЕДИНЕНИЕ ОДНОГО К ДРУГОМУ                                            //
///////////////////////////////////////////////////////////////////////////////

// параметры на присоединение полосок к башенным кластерам
//! пороги по theta (nsig,ths_min,ths_max) (см. ниже)
lkr2str_theta=2.0, 5.0, 20.0;
//! пороги по phi (nsig,ths_min,ths_max) (см. ниже)
lkr2str_phi=2.0, 5.0, 20.0;
//! пороги по phi для z-полосок (стык)
lkr2str_zphi=10.0, 2.5;

// параметры на присоединение кластеров LKr(башни) к трекам ДК
//! пороги по theta (nsig,ths_min,ths_max) (см. ниже)
lkr2dc_theta=5.0, 10.0, 20.0;
//! пороги по phi (nsig,ths_min,ths_max) (см. ниже)
lkr2dc_phi=5.0, 10.0, 20.0;

// параметры на присоединение кластеров LKr(башни) кластерам CsI
//! пороги по theta (nsig,ths_min,ths_max) (см. ниже)
lkr2csi_theta=5.0, 15.0, 20.0;
//! пороги по phi (nsig,ths_min,ths_max) (см. ниже)
lkr2csi_phi=5.0, 15.0, 20.0;

// параметры на присоединение кластеров CsI к трекам ДК
//! пороги по theta (nsig,ths_min,ths_max) (см. ниже)
csi2dc_theta=3.0, 10.0, 15.0;
//! пороги по phi (nsig,ths_min,ths_max) (см. ниже)
csi2dc_phi=3.0, 10.0, 15.0;


///////////////////////////////////////////////////////////////////////////////
// РАЗНОЕ                                                                    //
///////////////////////////////////////////////////////////////////////////////

//! Сдвиг LKr в систему координат ДК

//! \li 0 - обозначает, что преобразований не производится
//! \li 1 - параметры пробразований берутся:\n
//!     для экспериментальных заходов - из базы данных\n
//!     для моделирования - из файла с данными моделирования (т.е. из карт),
//! временно не работает.
//! \li 2 - параметры преобразований задаются в ручную в файле param.emc
lkrshift=1; 

//! Сдвиг CsI в систему координат ДК

//! \li 0 - обозначает, что преобразований не производится
//! \li 1 - параметры пробразований берутся:\n
//!     для экспериментальных заходов - из базы данных\n
//!     для моделирования - из файла с данными моделирования (т.е. из карт),
//! временно не работает.
//! \li 2 - параметры преобразований задаются в ручную в файле param.emc
csishift=1;

//emcshift_fname=/space/KEDR/stable/KEmcData/emcshift.txt; // файл со сдвигами LKr и CsI относительно ДК
//emcshift_fname=/space/KEDR/stable/KEmcData/emcshift_loc3.txt; // файл со сдвигами CsI относительно LKr

// Ручные параметры поворотов LKr, действуют при lkrshift=2

//! сдвиги LKr, список из трёх значений в порядке X, Y, Z
lkr.shiftpar=0.0, 0.0, 0.0;
//! повороты LKr, список из трёх углов Theta, Gamma, Phi
lkr.rotpar=0.0, 0.0, 0.0;

// Ручные параметры поворотов CsI, действуют при csishift=2
//! сдвиги модуля CsI1 ( X, Y, Z )
csi[1].shiftpar=0.0, 0.0, 0.0;
//! повороты модуля CsI1 ( Theta, Gamma, Phi )
csi[1].rotpar=0.0, 0.0, 0.0;

//! сдвиги модуля CsI2 ( X, Y, Z )
csi[2].shiftpar=0.0, 0.0, 0.0;
//! повороты модуля CsI2 ( Theta, Gamma, Phi )
csi[2].rotpar=0.0, 0.0, 0.0;

//! сдвиги модуля CsI3 ( X, Y, Z )
csi[3].shiftpar=0.0, 0.0, 0.0;
//! повороты модуля CsI3 ( Theta, Gamma, Phi )
csi[3].rotpar=0.0, 0.0, 0.0;

//! сдвиги модуля CsI4 ( X, Y, Z )
csi[4].shiftpar=0.0, 0.0, 0.0;
//! повороты модуля CsI4 ( Theta, Gamma, Phi )
csi[4].rotpar=0.0, 0.0, 0.0;

//! сдвиги модуля CsI5 ( X, Y, Z )
csi[5].shiftpar=0.0, 0.0, 0.0;
//! повороты модуля CsI5 ( Theta, Gamma, Phi )
csi[5].rotpar=0.0, 0.0, 0.0;

//! сдвиги модуля CsI6 ( X, Y, Z )
csi[6].shiftpar=0.0, 0.0, 0.0;
//! повороты модуля CsI6 ( Theta, Gamma, Phi )
csi[6].rotpar=0.0, 0.0, 0.0;

//! сдвиги модуля CsI7 ( X, Y, Z )
csi[7].shiftpar=0.0, 0.0, 0.0;
//! повороты модуля CsI7 ( Theta, Gamma, Phi )
csi[7].rotpar=0.0, 0.0, 0.0;  

//! сдвиги модуля CsI8 ( X, Y, Z )  
csi[8].shiftpar=0.0, 0.0, 0.0; 
//! повороты модуля CsI8 ( Theta, Gamma, Phi )  
csi[8].rotpar=0.0, 0.0, 0.0;   

// служебные параметры

//! служебная печать, см. ниже
emc_debug=0;
//! lkr, csi, str, str_track, dc_track
emc_debug_field=1,1,0,0,0;     
//! служебный стимулятор пользователя
emc_param_id=5;               
//! использование альтернативного вычисления координат стриповых кластеров
emc_stralt=1;
///////////////////////////////////////////////////////////////////////////////////
// - Tips 
// - Если строчки выкинуть или закомментировать, возьмутся значения по умолчанию.
// - Строчки можно переставлять местами.
// - Если например отключить чтение криптона read_lkr=0, то реконструкция в
//   нем отключится сама (т.е. необязательно еще делать и rec_lkr=0, rec_str=0, ...)
// - Важно: если вы передаете имя файла, как например в карте 
//   emcshift_fname=/home/pospelov/KEDR/KEmcData/emcshift_loc.txt;
//   то не должно быть пробела после знака '='
///////////////////////////////////////////////////////////////////////////////////

// emc_verbose
//  0- отсутствие печати. 1- +самое необходимое. 2- +некритичные предупреждения.
//  10 - +все подряд.

// #attach_lkr2str
// Полосочный кластер присоединяется к башенному, если выполняются соотношения
// fabs(lkr_theta-str_theta) < THS_THETA && fabs(lkr_phi-str_phi) < THS_PHI
// Здесь порог THS_THETA(в градусах) насчитывается исходя их карты
// lkr2str_theta=nsig, ths_min, ths_max;
// THS_THETA=nsig*(размер dtheta башенного кластера по theta в градусах), но
// если THS_THETA<ths_min то THS_THETA=ths_min
// если THS_THETA>ths_max то THS_THETA=ths_max
// Аналогично для угла phi

// attach_lkr2csi
// кластер LKr(башни) присоединяется к кластеру CsI, если выполняются соотношения
// fabs(lkr_theta-csi_theta) < THS_THETA && fabs(lkr_phi-csi_phi) < THS_PHI
// Здесь порог THS_THETA(в градусах) насчитывается исходя их карты
// lkr2csi_theta=nsig, ths_min, ths_max;
// THS_THETA=nsig*(lkr_dtheta+csi_dtheta)/2., где lkr_dtheta и csi_dtheta размеры
// кластеров. При этом,
// если THS_THETA<ths_min то THS_THETA=ths_min
// если THS_THETA>ths_max то THS_THETA=ths_max
// Аналогично для угла phi

// emc_debug=par;
// если этот параметр par>0 то в конце реконструкции события будет вызываться
// функция emc_debug(par), где параметр par отвечает за
// par=1 - печататать списки кластеров
// par=2 - печатать для кластера номера пришитых треков, кластеров, и списки плохих ячеек
// par=3 - печатать списки ячеек, входящие в кластер

// emc_debug_field
// параметр emc_debug_field=lkr, csi, str, str_track, dc_track позволяет
// запрещать ту или иную печатать. Можно например запретить печатать все, за 
// исключением информации по кластерам LKr(башни) поставив emc_debug_field=1,0,0,0,0;
// Работает при включенном emc_debug

// dctrack_mode=0/1;
// При приписывании треков ДК к кластерам калориметра для нас важнейшим является
// вопрос, как продлять треки до пересечения с радиусом кластра - в одну сторону,
// или в две? Если dctrack_mode=0 то трек будет продлятся в две 
// стороны, если его tVertex=0 и в одну сторону, если его tVertex=1;
// Если dctrack_mode=1 то будет добавлена дополнительная проверка: если tVertex=0,
// т.е. трек не является центральным, но его tPh0 находится вне отрезка tPh1 и
// tPh2 то трек будет продлятся тольео в одну сторону.
// dctrack_mode=0 больше подходит для обработки космики, dctrack_mode=1 больше для
// центральных событий.
